// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{TEST_ELF, TEST_ID};
use risc0_zkvm::{
    default_prover, get_prover_server, ExecutorEnv, ExecutorImpl, ProverOpts, VerifierContext,
};
use std::io::{self, Read};
use std::sync::mpsc;
use std::sync::mpsc::{Receiver, Sender};

fn prover_opts_fast() -> ProverOpts {
    ProverOpts {
        hashfn: "sha-256".to_string(),
        prove_guest_errors: false,
    }
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let mut input: u32 = 1;

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();
    let mut exec = ExecutorImpl::from_elf(env, TEST_ELF).unwrap();

    loop {
        // Run until sys_pause
        let mut session = exec.run().unwrap();

        let prover = get_prover_server(&prover_opts_fast()).unwrap();
        let receipt = prover
            .prove_session(&VerifierContext::default(), &session)
            .unwrap();

        // For example:
        let output: u32 = receipt.journal.decode().unwrap();
        println!("output: {output}");

        // TODO this verify doesn't work after the first. Probably need to use the ID from the previous output?
        // receipt.verify(TEST_ID).unwrap();
        input += 1;
        let env = ExecutorEnv::builder()
            .write(&input)
            .unwrap()
            .build()
            .unwrap();

        session.post_image.pc += 4;
        exec = ExecutorImpl::new(env, session.post_image).unwrap();
    }
}
