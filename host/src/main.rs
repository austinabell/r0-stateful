// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{TEST_ELF, TEST_ID};
use risc0_zkvm::{
    default_prover, get_prover_server, ExecutorEnv, ExecutorImpl, ProverOpts, VerifierContext,
};
use std::io::{self, Read};
use std::sync::mpsc;
use std::sync::mpsc::{Receiver, Sender};

fn prover_opts_fast() -> ProverOpts {
    ProverOpts {
        hashfn: "sha-256".to_string(),
        prove_guest_errors: false,
    }
}

// Don't look at these, just trying to have a readable channel ASAP, sure there is a cleaner way
struct ReadableChannel(mpsc::Receiver<u8>);
impl Read for ReadableChannel {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        for (i, byte) in buf.iter_mut().enumerate() {
            match self.0.try_recv() {
                Ok(data) => *byte = data,
                Err(_) => return Ok(i),
            }
        }
        Ok(buf.len())
    }
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let mut input: u32 = 1;

    // Setup mpsc channel to send data to guest
    let (tx, rx): (Sender<u8>, Receiver<u8>) = mpsc::channel();
    let env = ExecutorEnv::builder()
        .stdin(ReadableChannel(rx))
        .build()
        .unwrap();
    let mut exec = ExecutorImpl::from_elf(env, TEST_ELF).unwrap();

    loop {
        // Add input to receiver channel
        for byte in input.to_le_bytes() {
            tx.send(byte).unwrap();
        }

        // Run until sys_pause
        let session = exec.run().unwrap();

        let prover = get_prover_server(&prover_opts_fast()).unwrap();
        let receipt = prover
            .prove_session(&VerifierContext::default(), &session)
            .unwrap();

        // For example:
        let output: u32 = receipt.journal.decode().unwrap();
        println!("output: {output}");

        // TODO this verify doesn't work after the first. Probably need to use the ID from the previous output?
        // receipt.verify(TEST_ID).unwrap();
        input += 1;
    }

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
}
